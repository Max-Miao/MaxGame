<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰æ¶ˆæ¸¸æˆ</title>
    <style>
        /* ä¿æŒåŸæœ‰æ ·å¼ä¸å˜ */
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .game-title {
            font-size: 28px;
            margin-bottom: 20px;
            color: #333;
        }
        .game-instructions {
            margin: 20px 0;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-width: 400px;
            text-align: left;
        }
        canvas {
            border: 2px solid #333;
            background: white;
            border-radius: 5px;
        }
        #slotContainer {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 5px;
        }
        .slot {
            width: 60px;
            height: 60px;
            border: 2px solid #666;
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .restart-btn {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        .restart-btn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1 class="game-title">ä¸‰æ¶ˆæ¸¸æˆ</h1>
        <div class="game-instructions">
            <h3>æ¸¸æˆè¯´æ˜ï¼š</h3>
            <p>1. ç‚¹å‡»ä»»æ„å¯è§æ–¹å—å°†å…¶ç§»åˆ°ä¸‹æ–¹æ§½ä½</p>
            <p>2. æ”¶é›†ä¸‰ä¸ªç›¸åŒçš„ç¬¦å·å¯ä»¥æ¶ˆé™¤</p>
            <p>3. æ³¨æ„ï¼šæ§½ä½æœ€å¤šåªèƒ½æ”¾7ä¸ªæ–¹å—</p>
            <p>4. æ§½ä½æ»¡æ—¶å¯ä»¥ç‚¹å‡»é‡æ–°å¼€å§‹</p>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="slotContainer">
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
        </div>
        <button class="restart-btn" onclick="window.game.restart()">é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.slots = Array.from(document.querySelectorAll('.slot'));
                this.tileSize = 70;
                this.padding = 10;
                this.gridSize = 4;
                this.overlap = 20;
                
                this.canvas.width = this.tileSize * this.gridSize + this.padding * (this.gridSize + 1);
                this.canvas.height = this.canvas.width;
                
                this.tiles = [];
                this.selectedTiles = [];
                this.maxSlots = 7;
                this.animating = false;
                
                this.symbols = ['ğŸ¯', 'â­', 'ğŸ²', 'ğŸ¨', 'ğŸª', 'ğŸ¸', 'ğŸ­', 'ğŸ¡'];
                
                this.init();
            }

            init() {
                this.generateInitialTiles();
                this.draw();
                this.setupEventListeners();
            }

            restart() {
                // æ¸…ç©ºé€‰ä¸­çš„æ–¹å—
                this.selectedTiles = [];
                this.updateSlots();

                // æ‰“ä¹±ç°æœ‰æ–¹å—
                this.shuffleTiles();

                // é‡æ–°ç»˜åˆ¶
                this.draw();
            }

            shuffleTiles() {
                // æ”¶é›†æ‰€æœ‰ç°æœ‰æ–¹å—çš„ç¬¦å·
                let allSymbols = this.tiles.map(tile => tile.symbol);
                
                // æ‰“ä¹±ç¬¦å·é¡ºåº
                for (let i = allSymbols.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allSymbols[i], allSymbols[j]] = [allSymbols[j], allSymbols[i]];
                }

                // é‡æ–°åˆ†é…ç¬¦å·ç»™æ–¹å—
                this.tiles.forEach((tile, index) => {
                    tile.symbol = allSymbols[index];
                });
            }

            generateInitialTiles() {
                this.tiles = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const count = 2 + Math.floor(Math.random() * 2);
                        for (let layer = 0; layer < count; layer++) {
                            const symbol = this.symbols[Math.floor(Math.random() * this.symbols.length)];
                            const offsetX = layer * this.overlap;
                            const offsetY = layer * this.overlap;
                            
                            this.tiles.push({
                                symbol,
                                layer,
                                gridRow: row,
                                gridCol: col,
                                x: col * (this.tileSize + this.padding) + this.padding + offsetX,
                                y: row * (this.tileSize + this.padding) + this.padding + offsetY,
                                targetX: null,
                                targetY: null,
                                width: this.tileSize,
                                height: this.tileSize
                            });
                        }
                    }
                }
            }

            generateNewTile(row, col) {
                const existingTiles = this.tiles.filter(t => t.gridRow === row && t.gridCol === col);
                const layer = existingTiles.length;
                const symbol = this.symbols[Math.floor(Math.random() * this.symbols.length)];
                const offsetX = layer * this.overlap;
                const offsetY = layer * this.overlap;

                this.tiles.push({
                    symbol,
                    layer,
                    gridRow: row,
                    gridCol: col,
                    x: col * (this.tileSize + this.padding) + this.padding + offsetX,
                    y: row * (this.tileSize + this.padding) + this.padding + offsetY,
                    targetX: null,
                    targetY: null,
                    width: this.tileSize,
                    height: this.tileSize
                });
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGrid();
                
                // æŒ‰å±‚çº§ç»˜åˆ¶æ–¹å—
                const maxLayer = Math.max(...this.tiles.map(t => t.layer), 0);
                for (let layer = 0; layer <= maxLayer; layer++) {
                    this.tiles
                        .filter(tile => tile.layer === layer)
                        .forEach(tile => this.drawTile(tile));
                }

                if (this.animating) {
                    requestAnimationFrame(() => this.draw());
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = '#eee';
                this.ctx.lineWidth = 1;
                
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * (this.tileSize + this.padding) + this.padding;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, pos);
                    this.ctx.lineTo(this.canvas.width - this.padding, pos);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos, this.padding);
                    this.ctx.lineTo(pos, this.canvas.height - this.padding);
                    this.ctx.stroke();
                }
            }

            drawTile(tile) {
                if (tile.targetX !== null && tile.targetY !== null) {
                    const dx = tile.targetX - tile.x;
                    const dy = tile.targetY - tile.y;
                    const speed = 0.2;

                    if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                        tile.x += dx * speed;
                        tile.y += dy * speed;
                        this.animating = true;
                    } else {
                        tile.x = tile.targetX;
                        tile.y = tile.targetY;
                        tile.targetX = null;
                        tile.targetY = null;
                        this.animating = false;
                    }
                }

                // ç»˜åˆ¶æ–¹å—é˜´å½±
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                this.ctx.shadowBlur = 5;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;

                // ç»˜åˆ¶æ–¹å—èƒŒæ™¯
                this.ctx.fillStyle = '#ffffff';
                this.ctx.strokeStyle = '#666666';
                this.ctx.lineWidth = 2;

                this.roundRect(
                    tile.x,
                    tile.y,
                    tile.width,
                    tile.height,
                    10
                );
                this.ctx.fill();
                this.ctx.stroke();

                // é‡ç½®é˜´å½±
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;

                // ç»˜åˆ¶ç¬¦å·
                this.ctx.font = '40px Arial';
                this.ctx.fillStyle = '#000000';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(
                    tile.symbol,
                    tile.x + tile.width/2,
                    tile.y + tile.height/2
                );
            }

            roundRect(x, y, width, height, radius) {
                this.ctx.beginPath();
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.arcTo(x + width, y, x + width, y + radius, radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.arcTo(x, y + height, x, y + height - radius, radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.arcTo(x, y, x + radius, y, radius);
                this.ctx.closePath();
            }

            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    if (this.animating) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const clickedTile = this.findClickableTile(x, y);
                    if (clickedTile) {
                        this.handleTileClick(clickedTile);
                    }
                });
            }

            findClickableTile(x, y) {
                // è·å–ç‚¹å‡»ä½ç½®çš„ç½‘æ ¼åæ ‡
                const gridCol = Math.floor((x - this.padding) / (this.tileSize + this.padding));
                const gridRow = Math.floor((y - this.padding) / (this.tileSize + this.padding));
                
                // è·å–è¯¥ä½ç½®çš„æ‰€æœ‰æ–¹å—
                const tilesAtPosition = this.tiles.filter(tile => 
                    tile.gridRow === gridRow && tile.gridCol === gridCol
                ).sort((a, b) => b.layer - a.layer); // ä»ä¸Šåˆ°ä¸‹æ’åº

                // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨æ¯ä¸ªæ–¹å—çš„å¯è§åŒºåŸŸå†…
                for (const tile of tilesAtPosition) {
                    const relativeX = x - tile.x;
                    const relativeY = y - tile.y;

                    // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨æ–¹å—èŒƒå›´å†…
                    if (relativeX >= 0 && relativeX <= tile.width &&
                        relativeY >= 0 && relativeY <= tile.height) {
                        
                        // æ£€æŸ¥è¯¥åŒºåŸŸæ˜¯å¦è¢«æ›´ä¸Šå±‚çš„æ–¹å—å®Œå…¨è¦†ç›–
                        const isClickable = !tilesAtPosition.some(otherTile => 
                            otherTile.layer > tile.layer &&
                            relativeX >= (otherTile.x - tile.x) &&
                            relativeX <= (otherTile.x - tile.x + tile.width) &&
                            relativeY >= (otherTile.y - tile.y) &&
                            relativeY <= (otherTile.y - tile.y + tile.height)
                        );

                        if (isClickable) {
                            return tile;
                        }
                    }
                }
                return null;
            }

            handleTileClick(tile) {
                if (this.selectedTiles.length >= this.maxSlots) {
                    alert('æ§½ä½å·²æ»¡ï¼è¯·æ¶ˆé™¤ç›¸åŒå›¾æ¡ˆæˆ–é‡æ–°å¼€å§‹æ¸¸æˆã€‚');
                    return;
                }

                // ç§»é™¤è¢«ç‚¹å‡»çš„æ–¹å—
                this.tiles = this.tiles.filter(t => t !== tile);
                this.selectedTiles.push(tile);

                // æ›´æ–°åŒä¸€æ ¼å­ä¸­å‰©ä½™æ–¹å—çš„ä½ç½®
                this.updateTilePositions(tile.gridRow, tile.gridCol);
                
                this.updateSlots();
                this.checkMatch();
                this.draw();

                // æ£€æŸ¥æ˜¯å¦éœ€è¦ç”Ÿæˆæ–°æ–¹å—
                this.checkAndGenerateNewTiles();
            }

            updateTilePositions(row, col) {
                const tilesInCell = this.tiles.filter(t => 
                    t.gridRow === row && t.gridCol === col
                );

                // é‡æ–°è®¡ç®—æ¯ä¸ªæ–¹å—çš„å±‚çº§å’Œä½ç½®
                tilesInCell.sort((a, b) => a.layer - b.layer);
                tilesInCell.forEach((tile, index) => {
                    tile.layer = index;
                    tile.targetX = tile.gridCol * (this.tileSize + this.padding) + this.padding + index * this.overlap;
                    tile.targetY = tile.gridRow * (this.tileSize + this.padding) + this.padding + index * this.overlap;
                });

                if (tilesInCell.length > 0) {
                    this.animating = true;
                    requestAnimationFrame(() => this.draw());
                }
            }

            checkAndGenerateNewTiles() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const tilesInCell = this.tiles.filter(t => 
                            t.gridRow === row && t.gridCol === col
                        );
                        
                        if (tilesInCell.length < 2) {
                            this.generateNewTile(row, col);
                        }
                    }
                }
            }

            updateSlots() {
                this.slots.forEach((slot, index) => {
                    slot.textContent = this.selectedTiles[index]?.symbol || '';
                });
            }

            checkMatch() {
                const symbolCounts = {};
                this.selectedTiles.forEach(tile => {
                    symbolCounts[tile.symbol] = (symbolCounts[tile.symbol] || 0) + 1;
                });

                let matched = false;
                for (const [symbol, count] of Object.entries(symbolCounts)) {
                    if (count >= 3) {
                        this.selectedTiles = this.selectedTiles.filter(tile => tile.symbol !== symbol);
                        matched = true;
                    }
                }

                if (matched) {
                    this.updateSlots();
                }
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        window.onload = () => {
            window.game = new Game();
        };
    </script>
</body>
</html>
