<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊòüÈôÖÈÄÉÁîü - Space Escape</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
            color: #fff;
            background-image: 
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px);
            background-size: 550px 550px, 350px 350px, 250px 250px;
            animation: space-background 60s linear infinite;
        }
        
        @keyframes space-background {
            from { background-position: 0 0, 0 0, 0 0; }
            to { background-position: 550px 550px, 350px 350px, 250px 250px; }
        }

        #gameContainer {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 1px solid #30f;
            box-shadow: 0 0 20px #30f;
        }

        .game-title {
            font-size: 28px;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 0 0 10px #30f;
        }

        .status-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(48, 0, 255, 0.1);
            border-radius: 5px;
        }

        .status-item {
            text-align: center;
        }

        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: #30f;
        }

        canvas {
            border: 2px solid #30f;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            box-shadow: 0 0 10px #30f;
        }

        #eventPanel {
            margin-top: 20px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.2);
            border-radius: 5px;
            display: none;
        }

        .crystal {
            position: absolute;
            pointer-events: none;
            opacity: 0;
            transition: all 0.5s ease;
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px #30f; }
            50% { box-shadow: 0 0 20px #30f; }
            100% { box-shadow: 0 0 5px #30f; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1 class="game-title">ÊòüÈôÖÈÄÉÁîü</h1>
        <div class="status-panel">
            <div class="status-item">
                <div>ÁáÉÊñô</div>
                <div id="fuel" class="status-value">100</div>
            </div>
            <div class="status-item">
                <div>ËÉΩÈáèÊô∂‰Ωì</div>
                <div id="score" class="status-value">0</div>
            </div>
            <div class="status-item">
                <div>Ë∑ùÁ¶ªÈªëÊ¥û</div>
                <div id="distance" class="status-value">1000</div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="eventPanel"></div>
    </div>

    <script>
        class SpaceGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 8;
                this.tileSize = 60;
                this.padding = 5;
                
                this.canvas.width = this.tileSize * this.gridSize + this.padding * (this.gridSize + 1);
                this.canvas.height = this.canvas.width;
                
                this.crystals = [];
                this.selected = null;
                this.fuel = 100;
                this.score = 0;
                this.distance = 1000;
                this.isFirstLevel = true;
                
                this.crystalTypes = ['üíé', 'üåü', '‚ö°', 'üîÆ', 'üí´'];
                this.events = [
                    { name: 'ÈªëÊ¥ûÂπ≤Êâ∞', effect: 'ÁáÉÊñôÊ∂àËÄóÂä†ÂÄç', duration: 3 },
                    { name: 'Èô®Áü≥Èõ®', effect: 'Êó†Ê≥ïÁßªÂä®Êô∂‰Ωì', duration: 2 },
                    { name: 'Á©∫Èó¥Ë£ÇÁºù', effect: 'ÈöèÊú∫‰∫§Êç¢Êô∂‰Ωì‰ΩçÁΩÆ', duration: 1 }
                ];
                
                this.init();
            }

            init() {
                this.generateGrid();
                this.setupEventListeners();
                this.updateStatus();
                this.startEventTimer();
            }

            generateGrid() {
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const crystal = {
                            type: this.crystalTypes[Math.floor(Math.random() * this.crystalTypes.length)],
                            row,
                            col,
                            x: col * (this.tileSize + this.padding) + this.padding,
                            y: row * (this.tileSize + this.padding) + this.padding
                        };
                        this.crystals.push(crystal);
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ÁªòÂà∂ÁΩëÊ†ºËÉåÊôØ
                this.ctx.strokeStyle = '#30f';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * (this.tileSize + this.padding) + this.padding;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, pos);
                    this.ctx.lineTo(this.canvas.width - this.padding, pos);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.moveTo(pos, this.padding);
                    this.ctx.lineTo(pos, this.canvas.height - this.padding);
                    this.ctx.stroke();
                }

                // ÁªòÂà∂Êô∂‰Ωì
                this.crystals.forEach(crystal => {
                    this.ctx.font = '40px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    if (crystal === this.selected) {
                        this.ctx.shadowColor = '#30f';
                        this.ctx.shadowBlur = 20;
                    }
                    
                    this.ctx.fillText(
                        crystal.type,
                        crystal.x + this.tileSize/2,
                        crystal.y + this.tileSize/2
                    );
                    
                    this.ctx.shadowColor = 'transparent';
                    this.ctx.shadowBlur = 0;
                });
            }

            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const col = Math.floor((x - this.padding) / (this.tileSize + this.padding));
                    const row = Math.floor((y - this.padding) / (this.tileSize + this.padding));
                    
                    const clickedCrystal = this.crystals.find(c => c.row === row && c.col === col);
                    
                    if (clickedCrystal) {
                        if (!this.selected) {
                            this.selected = clickedCrystal;
                        } else {
                            if (this.isAdjacent(this.selected, clickedCrystal)) {
                                this.swapCrystals(this.selected, clickedCrystal);
                                if (!this.checkMatches()) {
                                    this.swapCrystals(clickedCrystal, this.selected);
                                } else {
                                    this.consumeFuel(1);
                                }
                            }
                            this.selected = null;
                        }
                        this.draw();
                    }
                });
            }

            isAdjacent(crystal1, crystal2) {
                const rowDiff = Math.abs(crystal1.row - crystal2.row);
                const colDiff = Math.abs(crystal1.col - crystal2.col);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }

            swapCrystals(crystal1, crystal2) {
                const tempX = crystal1.x;
                const tempY = crystal1.y;
                const tempRow = crystal1.row;
                const tempCol = crystal1.col;
                
                crystal1.x = crystal2.x;
                crystal1.y = crystal2.y;
                crystal1.row = crystal2.row;
                crystal1.col = crystal2.col;
                
                crystal2.x = tempX;
                crystal2.y = tempY;
                crystal2.row = tempRow;
                crystal2.col = tempCol;
            }

            checkMatches() {
                const matches = new Set();
                
                // Ê£ÄÊü•Ë°å
                for (let row = 0; row < this.gridSize; row++) {
                    let count = 1;
                    let type = null;
                    for (let col = 0; col < this.gridSize; col++) {
                        const crystal = this.crystals.find(c => c.row === row && c.col === col);
                        if (crystal.type === type) {
                            count++;
                            if (count >= 3) {
                                for (let i = 0; i < count; i++) {
                                    const matchedCrystal = this.crystals.find(
                                        c => c.row === row && c.col === col - i
                                    );
                                    matches.add(matchedCrystal);
                                }
                            }
                        } else {
                            count = 1;
                            type = crystal.type;
                        }
                    }
                }
                
                // Ê£ÄÊü•Âàó
                for (let col = 0; col < this.gridSize; col++) {
                    let count = 1;
                    let type = null;
                    for (let row = 0; row < this.gridSize; row++) {
                        const crystal = this.crystals.find(c => c.row === row && c.col === col);
                        if (crystal.type === type) {
                            count++;
                            if (count >= 3) {
                                for (let i = 0; i < count; i++) {
                                    const matchedCrystal = this.crystals.find(
                                        c => c.row === row - i && c.col === col
                                    );
                                    matches.add(matchedCrystal);
                                }
                            }
                        } else {
                            count = 1;
                            type = crystal.type;
                        }
                    }
                }
                
                if (matches.size > 0) {
                    this.handleMatches(Array.from(matches));
                    return true;
                }
                return false;
            }

            handleMatches(matches) {
                // Êõ¥Êñ∞ÂàÜÊï∞
                this.score += matches.length * 10;
                this.distance -= matches.length * 5;
                
                // ÁßªÈô§ÂåπÈÖçÁöÑÊô∂‰Ωì
                matches.forEach(crystal => {
                    const index = this.crystals.indexOf(crystal);
                    if (index > -1) {
                        this.crystals.splice(index, 1);
                    }
                });
                
                // ÁîüÊàêÊñ∞ÁöÑÊô∂‰Ωì
                this.fillEmptySpaces();
                
                // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÂèØËÉΩÁöÑÂåπÈÖç
                setTimeout(() => {
                    if (!this.hasPossibleMatches()) {
                        this.reshuffleGrid();
                    }
                    this.updateStatus();
                    this.draw();
                }, 300);
            }

            fillEmptySpaces() {
                for (let col = 0; col < this.gridSize; col++) {
                    let emptySpaces = 0;
                    for (let row = this.gridSize - 1; row >= 0; row--) {
                        const crystal = this.crystals.find(c => c.row === row && c.col === col);
                        if (!crystal) {
                            emptySpaces++;
                        } else if (emptySpaces > 0) {
                            crystal.row += emptySpaces;
                            crystal.y = crystal.row * (this.tileSize + this.padding) + this.padding;
                        }
                    }
                    
                    // Âú®È°∂ÈÉ®Ê∑ªÂä†Êñ∞ÁöÑÊô∂‰Ωì
                    for (let i = 0; i < emptySpaces; i++) {
                        const newCrystal = {
                            type: this.crystalTypes[Math.floor(Math.random() * this.crystalTypes.length)],
                            row: i - emptySpaces,
                            col: col,
                            x: col * (this.tileSize + this.padding) + this.padding,
                            y: (i - emptySpaces) * (this.tileSize + this.padding) + this.padding
                        };
                        this.crystals.push(newCrystal);
                    }
                }
            }

            hasPossibleMatches() {
                // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÂèØËÉΩÁöÑÂåπÈÖç
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const crystal = this.crystals.find(c => c.row === row && c.col === col);
                        
                        // Ê£ÄÊü•Âè≥‰æß‰∫§Êç¢
                        if (col < this.gridSize - 1) {
                            const rightCrystal = this.crystals.find(c => c.row === row && c.col === col + 1);
                            this.swapCrystals(crystal, rightCrystal);
                            if (this.checkMatches()) {
                                this.swapCrystals(rightCrystal, crystal);
                                return true;
                            }
                            this.swapCrystals(rightCrystal, crystal);
                        }
                        
                        // Ê£ÄÊü•‰∏ãÊñπ‰∫§Êç¢
                        if (row < this.gridSize - 1) {
                            const bottomCrystal = this.crystals.find(c => c.row === row + 1 && c.col === col);
                            this.swapCrystals(crystal, bottomCrystal);
                            if (this.checkMatches()) {
                                this.swapCrystals(bottomCrystal, crystal);
                                return true;
                            }
                            this.swapCrystals(bottomCrystal, crystal);
                        }
                    }
                }
                return false;
            }

            reshuffleGrid() {
                const types = this.crystals.map(c => c.type);
                for (let i = types.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [types[i], types[j]] = [types[j], types[i]];
                }
                this.crystals.forEach((crystal, index) => {
                    crystal.type = types[index];
                });
            }

            consumeFuel(amount) {
                if (!this.isFirstLevel) {
                    this.fuel -= amount;
                    if (this.fuel <= 0) {
                        this.gameOver();
                    }
                }
                this.updateStatus();
            }

            updateStatus() {
                document.getElementById('fuel').textContent = this.fuel;
                document.getElementById('score').textContent = this.score;
                document.getElementById('distance').textContent = this.distance;
                
                if (this.distance <= 0) {
                    this.levelComplete();
                }
            }

            startEventTimer() {
                setInterval(() => {
                    if (Math.random() < 0.1) { // 10%Ê¶ÇÁéáËß¶Âèë‰∫ã‰ª∂
                        this.triggerRandomEvent();
                    }
                }, 10000);
            }

            triggerRandomEvent() {
                const event = this.events[Math.floor(Math.random() * this.events.length)];
                const panel = document.getElementById('eventPanel');
                panel.style.display = 'block';
                panel.textContent = `Ë≠¶ÂëäÔºö${event.name} - ${event.effect}`;
                
                setTimeout(() => {
                    panel.style.display = 'none';
                }, event.duration * 1000);
            }

            gameOver() {
                alert(`Ê∏∏ÊàèÁªìÊùüÔºÅ\nÊî∂ÈõÜÁöÑËÉΩÈáèÊô∂‰ΩìÔºö${this.score}\nÂâ©‰ΩôË∑ùÁ¶ªÔºö${this.distance}`);
                this.restart();
            }

            levelComplete() {
                this.isFirstLevel = false;
                this.fuel = 50;
                this.distance = 1000;
                this.score = 0;
                alert('Á¨¨‰∏ÄÂÖ≥ÂÆåÊàêÔºÅËøõÂÖ•ÁîüÂ≠òÊ®°ÂºèÔºåÁáÉÊñôÊúâÈôêÔºÅ');
                this.restart();
            }

            restart() {
                this.crystals = [];
                this.selected = null;
                this.generateGrid();
                this.updateStatus();
                this.draw();
            }
        }

        // ÂêØÂä®Ê∏∏Êàè
        window.onload = () => {
            window.game = new SpaceGame();
        };
    </script>
</body>
</html>
